---
title: API Reference

language_tabs: # must be one of https://git.io/vQNgJ
  - python
  - javascript

includes:
  - errors

search: true

code_clipboard: true

meta:
  - name: description
    content: Documentation for Satori Perpetual Protocol
---

# Introduction

Welcome to the docs for the Satori Perpetual Protocol. Satori is a decentralized financial derivatives platform built on Polkadot. It features a hybrid of orderbook and AMM models to provide comprehensive exposure to a wide range of assets, and an “off-chain aggregation and on-chain settlement” design that combines the security and transparency of a decentralized exchange, with the speed and usability of a centralized exchange.

# Perpetual Contract Concepts

## Margin

Satori enforces margin requirements for users -- an initial margin rate to open and size-up positions, and a maintenance margin rate to avoid liquidations. These margin rates are determined on a per-token-pair basis.

### Initial Margin

### Maintenance Margin

This margin requirement is calculated as follows:

<aside class="formula">
  Maintenance margin = new opening cost * 105%
</aside>

### Transfer out restrictions

Users are not allowed to transfer out their account balance when the margin rate of their position is less than the alert margin rate.

<aside class="formula">
  Transferable amount = available balance / 105%.
</aside>

## Liquidations

Accounts where the margin rate is less than or equal to the maintenance margin rate may be liquidated.

The platform will continuously calculate the risk factor of position burst:

<aside class="formula">
  <code>
    risk of blow-out factor =
      maintenance margin / (available balance + position margin) * 100%.
  </code>
</aside>

When a position burst is about to be triggered, the platform will cancel all current open orders to release margin and maintain the position.

If the maintenance margin requirement is still not met after the cancellation of an outstanding order, this remaining position is taken over by the strong closing engine at the bankruptcy price (i.e., the price at which the equity in the user's account equals zero).

The user's forced liquidation record can be seen directly in the history of commissions and transactions. The price shown will be the bankruptcy price, not the forced liquidation price.

After the system takes over the position, if the market price is better than the bankruptcy price, the order will be delegated to the market to be filled in a matchmaking manner as soon as possible.

Upon forced liquidation, all the user's positions in all contracts will be forced to close. The loss of a user subject to forced liquidation is close to or equal to all the assets in his virtual contract account.

## Contract Losses

### Insurance Vault

When a user is liquidated, their remaining positions will be taken over by the forced liquidation system. If the liquidation cannot be filled by the time we reach the bankruptcy price, the loss will be covered by the insurance vault, a reserve maintained by the platform.

The main sources of the insurance vault are a percentage of the commission generated by the transaction, and the surplus of the burst position.

### Automatic Deleverage System

In the event that the insurance vault is insufficient to cover a liquidation loss, the Automatic Deleveraging System (ADL) will automatically deleverage traders holding positions in the opposite direction.

The ADL will deleverage traders in descending order of profit and leverage, i.e. the higher the profit and the more leverage used the higher the ranking.

Traders can view their priority ranking for automatic position reduction via the “ADL Ranking” indicator in the UI.

Positions will be reduced atomically: after the first user's position in line has been fully reduced, the second position will continue to be reduced and so on.

### ADL ranking calculation method

<aside class="formula">
    <code>
    Ranking =
            % profit * effective leverage (if profit, i.e. % profit > 0)

            OR

            % profit / effective leverage (if loss, i.e. % profit < 0)
    </code>

</aside>

Where:

- `Effective leverage` is `mark value / (mark value - bankruptcy value`
- `% profit` is `(mark value - average open value) / average open value`
- `Mark value` is the `value of position at mark price`
- `Bankruptcy value` is the `value of position at bankruptcy price`
- `Average open value` is the `value of position at average open price`

## Funding Costs

We anchor the market price of perpetual contracts to the spot price through a funding fee mechanism.

Long positions pay short positions when the market is bullish; short positions pay long positions when the market is bearish.

The funding fee is charged every 8 hours, at 4:00, 12:00 and 20:00 each day.

The funding fee is calculated as follows:

<aside class="formula">
<code>
  Funding fee =
    value of position held * funding fee rate
  </code>
</aside>

### Funding Fee Rate Calculation

The funding fee rate is comprised of two components: the interest rate and the premium.

The premium is calculated as:

<aside class="formula">
  <code>
  Premium =
    [Max(0, Impact Bid Price - Index Price) - Max(0, Index Price - Impact Ask Price)] /
    Price Index
</code>

</aside>

where the impact bid and impact ask prices refer to the average execution price for a market sell (bid) or market buy (ask) of the impact notational value.

Altogether, the funding fee rate is calculated as:

<aside class="formula">
    Funding fee rate = Premium + Clamp(Interest Rate - Premium, a, b)
</aside>

where for BTC, ETH, EOS, XRP, BCH, BSV, ETC, LTC, TRX, `a = -0.3%` and `b = 0.3%`

The `Clamp` function `Clamp(x, min, max)`, returns `min` when `x < = min` and `max` when `x>= max`.

## Index Price

To ensure that the spot index price reasonably reflects the fair spot market price of each coin, we utilize the Chainlink API. The index price is equal to the median of the reported prices of the 15 independent Chainlink master nodes.

In the event that the connection to Chainlink is lost, or Chainlink is down, we manually pull the spot indices from several mainstream exchanges and calculate the index price as a weighted average of the spot prices.

#### BTC/USD

`Okex`
`Binance`
`Coinbase`
`Bitstamp`

#### ETH/USD

`Okex`
`Binance`
`Coinbase`
`Bitstamp`

#### LTC/USD

`Okex`
`Coinbase`
`Bitstamp`

#### XRP/USD

`Okex`
`Coinbase`
`Bitstamp`

We has also implemented logic to ensure that index fluctuations are within the normal range when there is a significant deviation from the price of a single exchange.

If an exchange price deviates by more than 3% relative to the median price of all exchanges, that exchange price is calculated as:

<aside class="formula">
<code>
median * 0.97
OR
median * 1.03
</code>
</aside>

## Matchmaking

Orders will be aggregated by price-time on a FIFO basis. A transaction happens if there is a buy order that has a price equal or greater than a sell order, or if there is a market order placed in one direction and orders exist in the opposing direction

<!-- ```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
```

```shell
# With shell, you can just pass the correct header with each request
curl "api_endpoint_here" \
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require("kittn");

let api = kittn.authorize("meowmeowmeow");
```

> Make sure to replace `meowmeowmeow` with your API key.

Kittn uses API keys to allow access to the API. You can register a new Kittn API key at our [developer portal](http://example.com/developers).

Kittn expects for the API key to be included in all API requests to the server in a header that looks like the following:

`Authorization: meowmeowmeow`

<aside class="notice">
You must replace <code>meowmeowmeow</code> with your personal API key.
</aside>

# Kittens

## Get All Kittens

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.get
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.get()
```

```shell
curl "http://example.com/api/kittens" \
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require("kittn");

let api = kittn.authorize("meowmeowmeow");
let kittens = api.kittens.get();
```

> The above command returns JSON structured like this:

```json
[
  {
    "id": 1,
    "name": "Fluffums",
    "breed": "calico",
    "fluffiness": 6,
    "cuteness": 7
  },
  {
    "id": 2,
    "name": "Max",
    "breed": "unknown",
    "fluffiness": 5,
    "cuteness": 10
  }
]
```

This endpoint retrieves all kittens.

### HTTP Request

`GET http://example.com/api/kittens`

### Query Parameters

| Parameter    | Default | Description                                                                      |
| ------------ | ------- | -------------------------------------------------------------------------------- |
| include_cats | false   | If set to true, the result will also include cats.                               |
| available    | true    | If set to false, the result will include kittens that have already been adopted. |

<aside class="success">
Remember — a happy kitten is an authenticated kitten!
</aside>

## Get a Specific Kitten

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.get(2)
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.get(2)
```

```shell
curl "http://example.com/api/kittens/2" \
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require("kittn");

let api = kittn.authorize("meowmeowmeow");
let max = api.kittens.get(2);
```

> The above command returns JSON structured like this:

```json
{
  "id": 2,
  "name": "Max",
  "breed": "unknown",
  "fluffiness": 5,
  "cuteness": 10
}
```

This endpoint retrieves a specific kitten.

<aside class="warning">Inside HTML code blocks like this one, you can't use Markdown, so use <code>&lt;code&gt;</code> blocks to denote code.</aside>

### HTTP Request

`GET http://example.com/kittens/<ID>`

### URL Parameters

| Parameter | Description                      |
| --------- | -------------------------------- |
| ID        | The ID of the kitten to retrieve |

## Delete a Specific Kitten

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.delete(2)
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.delete(2)
```

```shell
curl "http://example.com/api/kittens/2" \
  -X DELETE \
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require("kittn");

let api = kittn.authorize("meowmeowmeow");
let max = api.kittens.delete(2);
```

> The above command returns JSON structured like this:

```json
{
  "id": 2,
  "deleted": ":("
}
```

This endpoint deletes a specific kitten.

### HTTP Request

`DELETE http://example.com/kittens/<ID>`

### URL Parameters

| Parameter | Description                    |
| --------- | ------------------------------ |
| ID        | The ID of the kitten to delete | -->
