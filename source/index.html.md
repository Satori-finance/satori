---
title: API Reference

language_tabs: # must be one of https://git.io/vQNgJ
  - python
  - javascript

includes:
  - errors

search: true

code_clipboard: true

meta:
  - name: description
    content: Documentation for Satori Perpetual Protocol
---

# Introduction

Welcome to the docs for the Satori Perpetual Protocol. Satori is a decentralized financial derivatives platform built on Polkadot. It features a hybrid of orderbook and AMM models to provide comprehensive exposure to a wide range of assets, and an “off-chain aggregation and on-chain settlement” design that combines the security and transparency of a decentralized exchange, with the speed and usability of a centralized exchange.

# Perpetual Contract Concepts

## Margin

Satori enforces margin requirements for users -- an initial margin reqirement to open and size-up positions, and a maintenance margin requirement to avoid liquidations. The margin requirements are calculated as follows:

<aside class="formula">
<code>
    Initial Margin Requirement = abs(S × OP × I)
  Maintenance Margin Requirement = abs(S × OP × M)
  </code>
</aside>

Where:

- `S` is the size of the position
- `OP` is the oracle price for the market
- `I` is the initial margin rate for the market
- `M` is the maintenance margin rate for the market

The margin rates are determined on a per-token-pair basis:

| Token Pair | Initial Margin Rate | Maintenance Margin Rate |
| ---------- | ------------------- | ----------------------- |
| BTC/USD    | 4%                  | 3%                      |
| ETH/USD    | 4%                  | 3%                      |
| LTC/USD    | 10%                 | 5%                      |
| XRP/USD    | 10%                 | 5%                      |

All collateral is held as USDC, and the quote asset for all perpetual markets is USDC. Satori uses cross-margining by default, meaning the margin is shared among all of the user's positions.

### Transfer out restrictions

Users are not allowed to transfer out their account balance when the margin rate of their position is less than the alert margin rate.

<aside class="formula">
  Transferable amount = available balance / 105%.
</aside>

## Liquidations

Accounts where the margin rate is less than or equal to the maintenance margin rate may be liquidated.

The platform will continuously calculate the risk factor of position burst:

<aside class="formula">
  <code>
    risk of blow-out factor =
      maintenance margin / (available balance + position margin) * 100%.
  </code>
</aside>

When a position burst is about to be triggered, the platform will cancel all current open orders to release margin and maintain the position.

If the maintenance margin requirement is still not met after the cancellation of an outstanding order, this remaining position is taken over by the strong closing engine at the bankruptcy price (i.e., the price at which the equity in the user's account equals zero).

The user's forced liquidation record can be seen directly in the history of commissions and transactions. The price shown will be the bankruptcy price, not the forced liquidation price.

After the system takes over the position, if the market price is better than the bankruptcy price, the order will be delegated to the market to be filled in a matchmaking manner as soon as possible.

Upon forced liquidation, all the user's positions in all contracts will be forced to close. The loss of a user subject to forced liquidation is close to or equal to all the assets in his virtual contract account.

## Contract Losses

### Insurance Vault

When a user is liquidated, their remaining positions will be taken over by the forced liquidation system. If the liquidation cannot be filled by the time we reach the bankruptcy price, the loss will be covered by the insurance vault, a reserve maintained by the platform.

The main sources of the insurance vault are a percentage of the commission generated by the transaction, and the surplus of the burst position.

### Automatic Deleverage System

In the event that the insurance vault is insufficient to cover a liquidation loss, the Automatic Deleveraging System (ADL) will automatically deleverage traders holding positions in the opposite direction.

The ADL will deleverage traders in descending order of profit and leverage, i.e. the higher the profit and the more leverage used the higher the ranking.

Traders can view their priority ranking for automatic position reduction via the “ADL Ranking” indicator in the UI.

Positions will be reduced atomically: after the first user's position in line has been fully reduced, the second position will continue to be reduced and so on.

### ADL ranking calculation method

<aside class="formula">
    <code>
    Ranking =
            % profit * effective leverage (if profit, i.e. % profit > 0)

            OR

            % profit / effective leverage (if loss, i.e. % profit < 0)
    </code>

</aside>

Where:

- `Effective leverage` is `mark value / (mark value - bankruptcy value)`
- `% profit` is `(mark value - average open value) / average open value`
- `Mark value` is the value of the position at mark price
- `Mark price` is the current price for the perpetual contracts of the asset you are viewing
- `Bankruptcy value` is the value of position at the bankruptcy price
- `Average open value` is the the value of position at average open price

## Funding Costs

We anchor the price of perpetual contracts to the spot index price through a funding fee mechanism.

Long positions pay short positions when the market is bullish; short positions pay long positions when the market is bearish.

The funding fee is charged every 8 hours, at 4:00, 12:00 and 20:00 each day.

The funding fee is calculated as follows:

<aside class="formula">
<code>
  Funding fee =
    value of position held * funding fee rate
  </code>
</aside>

### Funding Fee Rate Calculation

The funding fee rate is comprised of two components: the interest rate and the premium.

The premium is calculated as:

<aside class="formula">
  <code>
  Premium =
    [Max(0, Impact Bid Price - Index Price) - Max(0, Index Price - Impact Ask Price)] /
    Index Price
</code>

</aside>

where the impact bid and impact ask prices refer to the average execution price for a market sell (bid) or market buy (ask) of the impact notational value.

Altogether, the funding fee rate is calculated as:

<aside class="formula">
    Funding fee rate = Premium + Clamp(Interest Rate - Premium, a, b)
</aside>

where for BTC, ETH, EOS, XRP, BCH, BSV, ETC, LTC, TRX, `a = -0.3%` and `b = 0.3%`

The `Clamp` function `Clamp(x, min, max)`, returns `min` when `x < = min` and `max` when `x>= max`.

## Index Price

The `Index Price` refers to the price of the underlying asset on the spot market. It's aggregate price based off price data from multiple exchanges and is used to trigger stop orders.

The exchanges we aggregate from are as follows for each currency pair:

#### BTC/USD

`Okex`
`Binance`
`Coinbase`
`Bitstamp`

#### ETH/USD

`Okex`
`Binance`
`Coinbase`
`Bitstamp`

#### LTC/USD

`Okex`
`Coinbase`
`Bitstamp`

#### XRP/USD

`Okex`
`Coinbase`
`Bitstamp`

We have implemented logic to ensure that index fluctuations are within the normal range when there is a significant deviation from the price of a single exchange.

If an exchange price deviates by more than 3% relative to the median price of all exchanges, the weight that exchange is given will be reduced.

## Oracle Price

The `Oracle Price` is an aggregate price calculated using multiple on-chain price oracles. Oracle prices are used to determine collateralization and liquidations on Satori.

Since the oracle price is also an aggregate price, it offers similar protection from flash crashes as the index price does.

For the Alpha launch, Satori runs its own oracle nodes on Layer 2.

## Matchmaking

Orders will be aggregated by price-time on a FIFO basis. A transaction happens if there is a buy order that has a price equal or greater than a sell order, or if there is a market order placed in one direction and orders exist in the opposing direction

<!-- ```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
```

```shell
# With shell, you can just pass the correct header with each request
curl "api_endpoint_here" \
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require("kittn");

let api = kittn.authorize("meowmeowmeow");
```

> Make sure to replace `meowmeowmeow` with your API key.

Kittn uses API keys to allow access to the API. You can register a new Kittn API key at our [developer portal](http://example.com/developers).

Kittn expects for the API key to be included in all API requests to the server in a header that looks like the following:

`Authorization: meowmeowmeow`

<aside class="notice">
You must replace <code>meowmeowmeow</code> with your personal API key.
</aside>

# Kittens

## Get All Kittens

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.get
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.get()
```

```shell
curl "http://example.com/api/kittens" \
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require("kittn");

let api = kittn.authorize("meowmeowmeow");
let kittens = api.kittens.get();
```

> The above command returns JSON structured like this:

```json
[
  {
    "id": 1,
    "name": "Fluffums",
    "breed": "calico",
    "fluffiness": 6,
    "cuteness": 7
  },
  {
    "id": 2,
    "name": "Max",
    "breed": "unknown",
    "fluffiness": 5,
    "cuteness": 10
  }
]
```

This endpoint retrieves all kittens.

### HTTP Request

`GET http://example.com/api/kittens`

### Query Parameters

| Parameter    | Default | Description                                                                      |
| ------------ | ------- | -------------------------------------------------------------------------------- |
| include_cats | false   | If set to true, the result will also include cats.                               |
| available    | true    | If set to false, the result will include kittens that have already been adopted. |

<aside class="success">
Remember — a happy kitten is an authenticated kitten!
</aside>

## Get a Specific Kitten

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.get(2)
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.get(2)
```

```shell
curl "http://example.com/api/kittens/2" \
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require("kittn");

let api = kittn.authorize("meowmeowmeow");
let max = api.kittens.get(2);
```

> The above command returns JSON structured like this:

```json
{
  "id": 2,
  "name": "Max",
  "breed": "unknown",
  "fluffiness": 5,
  "cuteness": 10
}
```

This endpoint retrieves a specific kitten.

<aside class="warning">Inside HTML code blocks like this one, you can't use Markdown, so use <code>&lt;code&gt;</code> blocks to denote code.</aside>

### HTTP Request

`GET http://example.com/kittens/<ID>`

### URL Parameters

| Parameter | Description                      |
| --------- | -------------------------------- |
| ID        | The ID of the kitten to retrieve |

## Delete a Specific Kitten

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.delete(2)
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.delete(2)
```

```shell
curl "http://example.com/api/kittens/2" \
  -X DELETE \
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require("kittn");

let api = kittn.authorize("meowmeowmeow");
let max = api.kittens.delete(2);
```

> The above command returns JSON structured like this:

```json
{
  "id": 2,
  "deleted": ":("
}
```

This endpoint deletes a specific kitten.

### HTTP Request

`DELETE http://example.com/kittens/<ID>`

### URL Parameters

| Parameter | Description                    |
| --------- | ------------------------------ |
| ID        | The ID of the kitten to delete | -->
